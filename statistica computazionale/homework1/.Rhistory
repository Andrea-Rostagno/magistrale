plot(xseq, posteriori_valori, type = "l", col = "blue", lwd = 2,
main = "Distribuzione a Posteriori di mu", xlab = expression(mu), ylab = "Densità a posteriori") #disegno graficamente la densita a posteriori
#Punto 2   #ho modificato il nome alle variabili in modo da essere piu intuitive e nel pdf ho specificato a cosa corrispondono i vari elementi delle immagini
prior_mu <- function(valori_mu) {#creiamo la funzione a priori della media
dnorm(valori_mu,0,sqrt(100))
}
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
rnorm(x,0,sqrt(100))
}
verosomiglianza <- function(valori_mu,campione) {#creiamo la verosomiglianza
verosomiglianza_valori <- sapply(campione, function(z) {
log(f_logistic_normal(z, valori_mu, sigma))})   #utilizzo sapply in modo che ad ogni valore del campione venga calcolata la logistic normal, calcolo la log verosomiglianza per problemi relativi ai dati
return(exp(sum(verosomiglianza_valori)))#essendo che usiamo la log-verosomiglianza sarebbe exp(logA+logB)=exp(logA)*exp(logB)=A*B quindi prodotto tra verosomiglianze
}
posteriori_non_normalizzata <- function(valori_mu,campione){#scriviamo la posteriori non normalizzata (senza il dnominatore del teorema di bayes) che ha come parametro incognito i valori di mu mentre i campioni sono precedentemente calcolati
return(prior_mu(valori_mu)*verosomiglianza(valori_mu,campione))
}
integrale_denominatore <- integrate(function(m) posteriori_non_normalizzata(m, dati), lower = 0, upper = 3)$value#calcolo del denominatore
posteriori <- function(valori_mu, campione) {#calcolata la posteriori secondo il teorema di bayes
posteriori_non_normalizzata(valori_mu, campione) / integrale_denominatore
}
integrale_posteriori <- integrate(function(m) posteriori(m, dati), lower = 0, upper = 3)$value#verifico che la densita a posteriori integri a 1
xseq <- seq(0,3,0.01)
posteriori_valori <- sapply(xseq, function(m) posteriori(m, dati))#calcolo i corrispondenti valori di densità per ogni valore di mu
plot(xseq, posteriori_valori, type = "l", col = "blue", lwd = 2,
main = "Distribuzione a Posteriori di mu", xlab = expression(mu), ylab = "Densità a posteriori") #disegno graficamente la densita a posteriori
max_post <- function(m) {#utilizzo il kernel come richiesto dall'esercizio e non la posteriori completa
-posteriori_non_normalizzata(m,dati)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_post, interval = c(0.01, 2.99))
M_p2 <- result$minimum
M2 <- -result$objective#svolgo come nel punto precedente per trovare il massimo della funzione
y <- g(nsim)
#Punto 2   #ho modificato il nome alle variabili in modo da essere piu intuitive e nel pdf ho specificato a cosa corrispondono i vari elementi delle immagini
prior_mu <- function(valori_mu) {#creiamo la funzione a priori della media
dnorm(valori_mu,0,sqrt(100))
}
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(100))
}
verosomiglianza <- function(valori_mu,campione) {#creiamo la verosomiglianza
verosomiglianza_valori <- sapply(campione, function(z) {
log(f_logistic_normal(z, valori_mu, sigma))})   #utilizzo sapply in modo che ad ogni valore del campione venga calcolata la logistic normal, calcolo la log verosomiglianza per problemi relativi ai dati
return(exp(sum(verosomiglianza_valori)))#essendo che usiamo la log-verosomiglianza sarebbe exp(logA+logB)=exp(logA)*exp(logB)=A*B quindi prodotto tra verosomiglianze
}
posteriori_non_normalizzata <- function(valori_mu,campione){#scriviamo la posteriori non normalizzata (senza il dnominatore del teorema di bayes) che ha come parametro incognito i valori di mu mentre i campioni sono precedentemente calcolati
return(prior_mu(valori_mu)*verosomiglianza(valori_mu,campione))
}
integrale_denominatore <- integrate(function(m) posteriori_non_normalizzata(m, dati), lower = 0, upper = 3)$value#calcolo del denominatore
posteriori <- function(valori_mu, campione) {#calcolata la posteriori secondo il teorema di bayes
posteriori_non_normalizzata(valori_mu, campione) / integrale_denominatore
}
integrale_posteriori <- integrate(function(m) posteriori(m, dati), lower = 0, upper = 3)$value#verifico che la densita a posteriori integri a 1
xseq <- seq(0,3,0.01)
posteriori_valori <- sapply(xseq, function(m) posteriori(m, dati))#calcolo i corrispondenti valori di densità per ogni valore di mu
plot(xseq, posteriori_valori, type = "l", col = "blue", lwd = 2,
main = "Distribuzione a Posteriori di mu", xlab = expression(mu), ylab = "Densità a posteriori") #disegno graficamente la densita a posteriori
max_post <- function(m) {#utilizzo il kernel come richiesto dall'esercizio e non la posteriori completa
-posteriori_non_normalizzata(m,dati)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_post, interval = c(0.01, 2.99))
M_p2 <- result$minimum
M2 <- -result$objective#svolgo come nel punto precedente per trovare il massimo della funzione
y <- rnorm(nsim,0,sqrt(100))#campiono dalla g
u <- runif(nsim,0,M2*g(y))
y <- rnorm(nsim,0,sqrt(100))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M2*g(y))
}
#Esercizio 2
rm(list = ls())
#Impostiamo il seed
set.seed(295706)
#Impostiamo i parametri
mu <- runif(1,-1.5,1.5)
sigma <- runif(1,0.5,1.5)
a <- 0
b <- 1
#Scriviamo la funzione
logit <- function(x) {
log(x / (1 - x))
}
f_logistic_normal <- function(x, mu, sigma) {
return((1 / (x * (1 - x) * sqrt(2 * pi * sigma))) *
exp(-((logit(x) - mu)^2) / (2 * sigma)))
}
#Punto 1
max_ln <- function(x) {
-f_logistic_normal(x, mu, sigma)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_ln, interval = c(0.01, 0.99)) # Evitiamo i bordi 0 e 1
M_p1 <- result$minimum#Abbiamo trovato le cordinate del nostro massimo
M1 <- -result$objective
ndati <- 10
dati <- c()
i <- 1
while(i<=ndati){#ora calcolo 10 campioni come richiesta
y <- runif(1,a,b)#simulo due variabili uniformi nello spazio [a,b]x[0,M1]
u <- runif(1,0,M1)
if(u < f_logistic_normal (y,mu,sigma)){#condizione degli algoritmi accept-reject
dati[i] <- y
i <- i+1
}
}#al termine di questo ciclo avremo ottenuto il nostro campione di 10 dati
nsim <- 10000
y <- runif(nsim, a,b)
u <- runif(nsim, 0,M1)
X = y [u < f_logistic_normal (y,mu,sigma)]
U_X = u[u < f_logistic_normal (y,mu,sigma)]#questa parte serve solo a mostrare che su 10000 simulazioni ne vengono accettate più 1000 come richiesto nelle regole dell'homework
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(X),"\n")
xseq = seq (0 ,1 , by =0.01)
plot (xseq , f_logistic_normal(xseq,mu,sigma) , ylim =c (0 , M1) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (X ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density (X , from =0 , to = 1) , col =2 , lwd =2)#infine vengono mostrate visivamente le 10000 simulazioni
#Punto 2   #ho modificato il nome alle variabili in modo da essere piu intuitive e nel pdf ho specificato a cosa corrispondono i vari elementi delle immagini
prior_mu <- function(valori_mu) {#creiamo la funzione a priori della media
dnorm(valori_mu,0,sqrt(100))
}
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(100))
}
verosomiglianza <- function(valori_mu,campione) {#creiamo la verosomiglianza
verosomiglianza_valori <- sapply(campione, function(z) {
log(f_logistic_normal(z, valori_mu, sigma))})   #utilizzo sapply in modo che ad ogni valore del campione venga calcolata la logistic normal, calcolo la log verosomiglianza per problemi relativi ai dati
return(exp(sum(verosomiglianza_valori)))#essendo che usiamo la log-verosomiglianza sarebbe exp(logA+logB)=exp(logA)*exp(logB)=A*B quindi prodotto tra verosomiglianze
}
posteriori_non_normalizzata <- function(valori_mu,campione){#scriviamo la posteriori non normalizzata (senza il dnominatore del teorema di bayes) che ha come parametro incognito i valori di mu mentre i campioni sono precedentemente calcolati
return(prior_mu(valori_mu)*verosomiglianza(valori_mu,campione))
}
integrale_denominatore <- integrate(function(m) posteriori_non_normalizzata(m, dati), lower = 0, upper = 3)$value#calcolo del denominatore
posteriori <- function(valori_mu, campione) {#calcolata la posteriori secondo il teorema di bayes
posteriori_non_normalizzata(valori_mu, campione) / integrale_denominatore
}
integrale_posteriori <- integrate(function(m) posteriori(m, dati), lower = 0, upper = 3)$value#verifico che la densita a posteriori integri a 1
xseq <- seq(0,3,0.01)
posteriori_valori <- sapply(xseq, function(m) posteriori(m, dati))#calcolo i corrispondenti valori di densità per ogni valore di mu
plot(xseq, posteriori_valori, type = "l", col = "blue", lwd = 2,
main = "Distribuzione a Posteriori di mu", xlab = expression(mu), ylab = "Densità a posteriori") #disegno graficamente la densita a posteriori
max_post <- function(m) {#utilizzo il kernel come richiesto dall'esercizio e non la posteriori completa
-posteriori_non_normalizzata(m,dati)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_post, interval = c(0.01, 2.99))
M_p2 <- result$minimum
M2 <- -result$objective#svolgo come nel punto precedente per trovare il massimo della funzione
y <- rnorm(nsim,0,sqrt(100))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M2*g(y))
}
u1<-runif(nsim,0,M2*g(y))
#Esercizio 2
rm(list = ls())
#Impostiamo il seed
set.seed(295706)
#Impostiamo i parametri
mu <- runif(1,-1.5,1.5)
sigma <- runif(1,0.5,1.5)
a <- 0
b <- 1
#Scriviamo la funzione
logit <- function(x) {
log(x / (1 - x))
}
f_logistic_normal <- function(x, mu, sigma) {
return((1 / (x * (1 - x) * sqrt(2 * pi * sigma))) *
exp(-((logit(x) - mu)^2) / (2 * sigma)))
}
#Punto 1
max_ln <- function(x) {
-f_logistic_normal(x, mu, sigma)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_ln, interval = c(0.01, 0.99)) # Evitiamo i bordi 0 e 1
M_p1 <- result$minimum#Abbiamo trovato le cordinate del nostro massimo
M1 <- -result$objective
ndati <- 10
dati <- c()
i <- 1
while(i<=ndati){#ora calcolo 10 campioni come richiesta
y <- runif(1,a,b)#simulo due variabili uniformi nello spazio [a,b]x[0,M1]
u <- runif(1,0,M1)
if(u < f_logistic_normal (y,mu,sigma)){#condizione degli algoritmi accept-reject
dati[i] <- y
i <- i+1
}
}#al termine di questo ciclo avremo ottenuto il nostro campione di 10 dati
nsim <- 10000
y <- runif(nsim, a,b)
u <- runif(nsim, 0,M1)
X = y [u < f_logistic_normal (y,mu,sigma)]
U_X = u[u < f_logistic_normal (y,mu,sigma)]#questa parte serve solo a mostrare che su 10000 simulazioni ne vengono accettate più 1000 come richiesto nelle regole dell'homework
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(X),"\n")
xseq = seq (0 ,1 , by =0.01)
plot (xseq , f_logistic_normal(xseq,mu,sigma) , ylim =c (0 , M1) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (X ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density (X , from =0 , to = 1) , col =2 , lwd =2)#infine vengono mostrate visivamente le 10000 simulazioni
#Punto 2   #ho modificato il nome alle variabili in modo da essere piu intuitive e nel pdf ho specificato a cosa corrispondono i vari elementi delle immagini
prior_mu <- function(valori_mu) {#creiamo la funzione a priori della media
dnorm(valori_mu,0,sqrt(100))
}
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(100))
}
verosomiglianza <- function(valori_mu,campione) {#creiamo la verosomiglianza
verosomiglianza_valori <- sapply(campione, function(z) {
log(f_logistic_normal(z, valori_mu, sigma))})   #utilizzo sapply in modo che ad ogni valore del campione venga calcolata la logistic normal, calcolo la log verosomiglianza per problemi relativi ai dati
return(exp(sum(verosomiglianza_valori)))#essendo che usiamo la log-verosomiglianza sarebbe exp(logA+logB)=exp(logA)*exp(logB)=A*B quindi prodotto tra verosomiglianze
}
posteriori_non_normalizzata <- function(valori_mu,campione){#scriviamo la posteriori non normalizzata (senza il dnominatore del teorema di bayes) che ha come parametro incognito i valori di mu mentre i campioni sono precedentemente calcolati
return(prior_mu(valori_mu)*verosomiglianza(valori_mu,campione))
}
integrale_denominatore <- integrate(function(m) posteriori_non_normalizzata(m, dati), lower = 0, upper = 3)$value#calcolo del denominatore
posteriori <- function(valori_mu, campione) {#calcolata la posteriori secondo il teorema di bayes
posteriori_non_normalizzata(valori_mu, campione) / integrale_denominatore
}
integrale_posteriori <- integrate(function(m) posteriori(m, dati), lower = 0, upper = 3)$value#verifico che la densita a posteriori integri a 1
xseq <- seq(0,3,0.01)
posteriori_valori <- sapply(xseq, function(m) posteriori(m, dati))#calcolo i corrispondenti valori di densità per ogni valore di mu
plot(xseq, posteriori_valori, type = "l", col = "blue", lwd = 2,
main = "Distribuzione a Posteriori di mu", xlab = expression(mu), ylab = "Densità a posteriori") #disegno graficamente la densita a posteriori
max_post <- function(m) {#utilizzo il kernel come richiesto dall'esercizio e non la posteriori completa
-posteriori_non_normalizzata(m,dati)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_post, interval = c(0.01, 2.99))
M_p2 <- result$minimum
M2 <- -result$objective#svolgo come nel punto precedente per trovare il massimo della funzione
y <- rnorm(nsim,0,sqrt(100))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M2*g(y))
}
u1<-runif(nsim,0,M2*g(y))
#Esercizio 2
rm(list = ls())
#Impostiamo il seed
set.seed(295706)
#Impostiamo i parametri
mu <- runif(1,-1.5,1.5)
sigma <- runif(1,0.5,1.5)
a <- 0
b <- 1
#Scriviamo la funzione
logit <- function(x) {
log(x / (1 - x))
}
f_logistic_normal <- function(x, mu, sigma) {
return((1 / (x * (1 - x) * sqrt(2 * pi * sigma))) *
exp(-((logit(x) - mu)^2) / (2 * sigma)))
}
#Punto 1
max_ln <- function(x) {
-f_logistic_normal(x, mu, sigma)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_ln, interval = c(0.01, 0.99)) # Evitiamo i bordi 0 e 1
M_p1 <- result$minimum#Abbiamo trovato le cordinate del nostro massimo
M1 <- -result$objective
ndati <- 10
dati <- c()
i <- 1
while(i<=ndati){#ora calcolo 10 campioni come richiesta
y <- runif(1,a,b)#simulo due variabili uniformi nello spazio [a,b]x[0,M1]
u <- runif(1,0,M1)
if(u < f_logistic_normal (y,mu,sigma)){#condizione degli algoritmi accept-reject
dati[i] <- y
i <- i+1
}
}#al termine di questo ciclo avremo ottenuto il nostro campione di 10 dati
nsim <- 10000
y <- runif(nsim, a,b)
u <- runif(nsim, 0,M1)
X = y [u < f_logistic_normal (y,mu,sigma)]
U_X = u[u < f_logistic_normal (y,mu,sigma)]#questa parte serve solo a mostrare che su 10000 simulazioni ne vengono accettate più 1000 come richiesto nelle regole dell'homework
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(X),"\n")
xseq = seq (0 ,1 , by =0.01)
plot (xseq , f_logistic_normal(xseq,mu,sigma) , ylim =c (0 , M1) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (X ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density (X , from =0 , to = 1) , col =2 , lwd =2)#infine vengono mostrate visivamente le 10000 simulazioni
#Punto 2   #ho modificato il nome alle variabili in modo da essere piu intuitive e nel pdf ho specificato a cosa corrispondono i vari elementi delle immagini
prior_mu <- function(valori_mu) {#creiamo la funzione a priori della media
dnorm(valori_mu,0,sqrt(100))
}
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(100))
}
verosomiglianza <- function(valori_mu,campione) {#creiamo la verosomiglianza
verosomiglianza_valori <- sapply(campione, function(z) {
log(f_logistic_normal(z, valori_mu, sigma))})   #utilizzo sapply in modo che ad ogni valore del campione venga calcolata la logistic normal, calcolo la log verosomiglianza per problemi relativi ai dati
return(exp(sum(verosomiglianza_valori)))#essendo che usiamo la log-verosomiglianza sarebbe exp(logA+logB)=exp(logA)*exp(logB)=A*B quindi prodotto tra verosomiglianze
}
posteriori_non_normalizzata <- function(valori_mu,campione){#scriviamo la posteriori non normalizzata (senza il dnominatore del teorema di bayes) che ha come parametro incognito i valori di mu mentre i campioni sono precedentemente calcolati
return(prior_mu(valori_mu)*verosomiglianza(valori_mu,campione))
}
integrale_denominatore <- integrate(function(m) posteriori_non_normalizzata(m, dati), lower = 0, upper = 3)$value#calcolo del denominatore
posteriori <- function(valori_mu, campione) {#calcolata la posteriori secondo il teorema di bayes
posteriori_non_normalizzata(valori_mu, campione) / integrale_denominatore
}
integrale_posteriori <- integrate(function(m) posteriori(m, dati), lower = 0, upper = 3)$value#verifico che la densita a posteriori integri a 1
xseq <- seq(0,3,0.01)
posteriori_valori <- sapply(xseq, function(m) posteriori(m, dati))#calcolo i corrispondenti valori di densità per ogni valore di mu
plot(xseq, posteriori_valori, type = "l", col = "blue", lwd = 2,
main = "Distribuzione a Posteriori di mu", xlab = expression(mu), ylab = "Densità a posteriori") #disegno graficamente la densita a posteriori
max_post <- function(m) {#utilizzo il kernel come richiesto dall'esercizio e non la posteriori completa
-posteriori_non_normalizzata(m,dati)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_post, interval = c(0.01, 2.99))
M_p2 <- result$minimum
M2 <- -result$objective#svolgo come nel punto precedente per trovare il massimo della funzione
y <- rnorm(nsim,0,sqrt(100))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M2*g(y[i]))
}
u1<-runif(nsim,0,M2*g(y))
campione_accettato_della_posteriori <- y [u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(20))
}
y <- rnorm(nsim,0,sqrt(20))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M2*g(y[i]))
}
campione_accettato_della_posteriori <- y [u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]
U_X = u[u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]#seleziono i parametri che rispettano i vincoli dell accept reject
xseq <- seq (0 ,10 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
xseq <- seq (0 ,3 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
plot (xseq , sapply(xseq, function(m) posteriori(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
plot (xseq , sapply(xseq, function(m) posteriori(m, dati)) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
posteriori_non_normalizzata(1,dati)
g(1)
posteriori_non_normalizzata(2,dati)
g(2)
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(100))
}
g(2)
#Punto 2   #ho modificato il nome alle variabili in modo da essere piu intuitive e nel pdf ho specificato a cosa corrispondono i vari elementi delle immagini
prior_mu <- function(valori_mu) {#creiamo la funzione a priori della media
dnorm(valori_mu,0,sqrt(100))
}
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(20))
}
posteriori_non_normalizzata(2,dati)
g(2)
posteriori_non_normalizzata(1.41,dati)
g(1.41)
M<-M2/g(M_p2)
M<-M2/g(M_p2)*1.15
#Punto 2   #ho modificato il nome alle variabili in modo da essere piu intuitive e nel pdf ho specificato a cosa corrispondono i vari elementi delle immagini
prior_mu <- function(valori_mu) {#creiamo la funzione a priori della media
dnorm(valori_mu,0,sqrt(100))
}
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(20))
}
verosomiglianza <- function(valori_mu,campione) {#creiamo la verosomiglianza
verosomiglianza_valori <- sapply(campione, function(z) {
log(f_logistic_normal(z, valori_mu, sigma))})   #utilizzo sapply in modo che ad ogni valore del campione venga calcolata la logistic normal, calcolo la log verosomiglianza per problemi relativi ai dati
return(exp(sum(verosomiglianza_valori)))#essendo che usiamo la log-verosomiglianza sarebbe exp(logA+logB)=exp(logA)*exp(logB)=A*B quindi prodotto tra verosomiglianze
}
posteriori_non_normalizzata <- function(valori_mu,campione){#scriviamo la posteriori non normalizzata (senza il dnominatore del teorema di bayes) che ha come parametro incognito i valori di mu mentre i campioni sono precedentemente calcolati
return(prior_mu(valori_mu)*verosomiglianza(valori_mu,campione))
}
integrale_denominatore <- integrate(function(m) posteriori_non_normalizzata(m, dati), lower = 0, upper = 3)$value#calcolo del denominatore
posteriori <- function(valori_mu, campione) {#calcolata la posteriori secondo il teorema di bayes
posteriori_non_normalizzata(valori_mu, campione) / integrale_denominatore
}
integrale_posteriori <- integrate(function(m) posteriori(m, dati), lower = 0, upper = 3)$value#verifico che la densita a posteriori integri a 1
xseq <- seq(0,3,0.01)
posteriori_valori <- sapply(xseq, function(m) posteriori(m, dati))#calcolo i corrispondenti valori di densità per ogni valore di mu
plot(xseq, posteriori_valori, type = "l", col = "blue", lwd = 2,
main = "Distribuzione a Posteriori di mu", xlab = expression(mu), ylab = "Densità a posteriori") #disegno graficamente la densita a posteriori
max_post <- function(m) {#utilizzo il kernel come richiesto dall'esercizio e non la posteriori completa
-posteriori_non_normalizzata(m,dati)# Usiamo il segno negativo per trovare il massimo con optimize
}
result <- optimize(max_post, interval = c(0.01, 2.99))
M_p2 <- result$minimum
M2 <- -result$objective#svolgo come nel punto precedente per trovare il massimo della funzione
M<-M2/g(M_p2)*1.15 #trovo M da usare nel metodo accept reject aumentato del 15%
y <- rnorm(nsim,0,sqrt(20))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M*g(y[i]))#campiono dall uniforme 0,M2*g(y)
}
campione_accettato_della_posteriori <- y [u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]
U_X <- u[u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]#seleziono i parametri che rispettano i vincoli dell accept reject
xseq <- seq (0 ,3 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(10))
}
M<-M2/g(M_p2)*1.15 #trovo M da usare nel metodo accept reject aumentato del 15%
y <- rnorm(nsim,0,sqrt(10))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M*g(y[i]))#campiono dall uniforme 0,M*g(y)
}
campione_accettato_della_posteriori <- y [u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]
U_X <- u[u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]#seleziono i parametri che rispettano i vincoli dell accept reject
xseq <- seq (0 ,3 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
xseq <- seq (0 ,10 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,0,sqrt(5))
}
M<-M2/g(M_p2)*1.15 #trovo M da usare nel metodo accept reject aumentato del 15%
y <- rnorm(nsim,0,sqrt(10))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M*g(y[i]))#campiono dall uniforme 0,M*g(y)
}
campione_accettato_della_posteriori <- y [u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]
U_X <- u[u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]#seleziono i parametri che rispettano i vincoli dell accept reject
xseq <- seq (0 ,10 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,1,sqrt(10))
}
M<-M2/g(M_p2)*1.15 #trovo M da usare nel metodo accept reject aumentato del 15%
y <- rnorm(nsim,1,sqrt(10))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M*g(y[i]))#campiono dall uniforme 0,M*g(y)
}
campione_accettato_della_posteriori <- y [u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]
U_X <- u[u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]#seleziono i parametri che rispettano i vincoli dell accept reject
xseq <- seq (0 ,10 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,1,sqrt(8))
}
M<-M2/g(M_p2)*1.15 #trovo M da usare nel metodo accept reject aumentato del 15%
y <- rnorm(nsim,1,sqrt(8))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M*g(y[i]))#campiono dall uniforme 0,M*g(y)
}
campione_accettato_della_posteriori <- y [u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]
U_X <- u[u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]#seleziono i parametri che rispettano i vincoli dell accept reject
xseq <- seq (0 ,10 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
xseq <- seq (0 ,3 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
g <- function(x) {#creiamo la funzione g(x) per campionare con il metodo accept-reject
dnorm(x,1,sqrt(6))
}
M<-M2/g(M_p2)*1.15 #trovo M da usare nel metodo accept reject aumentato del 15%
y <- rnorm(nsim,1,sqrt(6))#campiono dalla g
u<- c()
for (i in 1:nsim) {
u[i]<-runif(1,0,M*g(y[i]))#campiono dall uniforme 0,M*g(y)
}
campione_accettato_della_posteriori <- y [u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]
U_X <- u[u < sapply(y, function(m) posteriori_non_normalizzata(m, dati))]#seleziono i parametri che rispettano i vincoli dell accept reject
xseq <- seq (0 ,3 ,0.01)
plot (xseq , sapply(xseq, function(m) posteriori_non_normalizzata(m, dati)) , ylim =c (0 , M2) ,type ="l ", lwd =2)
points (y,u , pch =20 , cex = 0.1)
points (campione_accettato_della_posteriori ,U_X , pch =20 , cex = 0.1 , col =2)
lines ( density ( campione_accettato_della_posteriori, from =0 , to = 3) , col =2 , lwd =2)#disegno come il punto precedente
cat("Numero di simulazioni accettate su 10000 simulazioni:",length(campione_accettato_della_posteriori),"\n")#soddisfo i 1000 campioni accettati
